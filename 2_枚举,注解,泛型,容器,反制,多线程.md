# 枚举

> 当需要定义一组常量时，强烈建议使用枚举类，使用enum关键字定义枚举类

# 枚举类的定义

```java
public enum PayType {
    ALIPAY(1, "支付宝"),
    WEIXINPAY(2, "微信"),
    PAYPAL(3, "PAYPAL"),
    BANK(4,"银行卡"),
    CREDIT(5,"信用卡"),
    BALANCE(4, "余额")
    ;

    private final Integer payCode;
    private final String payName;

    private PayType(Integer payCode, String payName) {
        this.payCode = payCode;
        this.payName = payName;
    }

    public Integer getPayCode() {
        return payCode;
    }

    public String getPayName() {
        return payName;
    }
}
```

# 实现接口的枚举类

> - [ ] 和普通 Java 类一样,枚举类可以实现一个或多个接口。
> - [ ] 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只
>   要统一实现该方法即可。
> - [ ] 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式,则可以让每个枚举值分别来实现该方法。

```java
/**
 * 季节枚举类
 */
public enum SeasonType implements Info {
    SPRING(1, "春天") {
        @Override
        public String show() {
            return "季节编码:" + getSeasonCode() + "-" + "季节名称:" + getSeasonName();
        }
    },
    SUMMER(2, "夏天") {
        @Override
        public String show() {
            return "季节编码:" + getSeasonCode() + "-" + "季节名称:" + getSeasonName();
        }
    },
    AUTUMN(3, "秋天") {
        @Override
        public String show() {
            return "季节编码:" + getSeasonCode() + "-" + "季节名称:" + getSeasonName();
        }
    },
    WINTER(4, "冬天") {
        @Override
        public String show() {
            return "季节编码:" + getSeasonCode() + "-" + "季节名称:" + getSeasonName();
        }
    };
    private final Integer seasonCode;
    private final String seasonName;

    SeasonType(Integer seasonCode, String seasonName) {
        this.seasonCode = seasonCode;
        this.seasonName = seasonName;
    }

    public String getSeasonName() {
        return seasonName;
    }

    public Integer getSeasonCode() {
        return seasonCode;
    }
}

interface Info {
    String show();
}

class SeasonEnumTets1 {
    public static void main(String[] args) {
        //遍历所有枚举对象并调用show方法
        for (SeasonType value : SeasonType.values()) {
            System.out.println(value.show());
        }
    }
}
```

# 注解(Annotation)

> - [ ] **Annotation**就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。
>
> - [ ] 通过使用**Annotation**,程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。

# JDK内置的三个基本注解

> - [ ] @Override: 限定重写父类方法, 该注解只能用于方法
> - [ ] @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择
> - [ ] @SuppressWarnings: 抑制编译器警告

# (false)Collection接口方法

> - 添加：add(Object obj),addAll(Collection coll)
>
>   - ```java
>     /*1.add(Object e):添加元素*/
>     Collection coll1 = new ArrayList();
>     coll1.add(456);
>     coll1.add("CC");
>     System.out.println(coll1.size());//2
>     
>     /*2.addAll(Collection coll1):添加多个元素*/
>     Collection coll = new ArrayList();
>     coll.addAll(coll1);
>     ```
>
> - 获取元素个数：int size()
>
>   - ```java
>     Collection coll = new ArrayList();
>     coll1.add("CC");
>     System.out.println(coll.size());//1
>     ```
>
> - 清空集合：void clear()
>
>   - ```java
>     //clear():清空集合元素
>     coll.clear();
>     ```
>
> - 是否是空集合：boolean isEmpty()
>
>   - ```java
>     //isEmpty():判断当前集合是否为空
>     System.out.println(coll.isEmpty());
>     ```
>
> - 是否包含某个元素
>
>   - boolean contains(Object obj)：是通过元素的equals方法来判断是否是同一个对象
>
>   - boolean containsAll(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。
>
>   - ```java
>     public void test2(){
>         Collection coll = new ArrayList();
>         coll.add(123);
>         coll.add(456);
>         Person p = new Person("Jerry",20);
>         coll.add(p);
>         coll.add(new Person("Jerry",20));
>         coll.add(new String("Tom"));
>         coll.add(false);
>     
>         //1.contains(Object obj):判断当前集合中是否包含obj 我们在判断时会调用obj对象所在类的equals()。
>         System.out.println(coll.contains(123)); //true
>         System.out.println(coll.contains(new String("Tom"))); //true
>         //没有equals是false -->反之true
>         System.out.println(coll.contains(p));//true
>         //没有equals是false -->反之true
>         System.out.println(coll.contains(new Person("Jerry",20))); //true
>     
>         //2.containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在于当前集合中。
>         Collection coll1 = Arrays.asList(123,4567);
>         System.out.println(coll.containsAll(coll1)); //false
>     }
>     ```
>
> - 删除：
>
>   - remove(Object obj):从当前集合中移除obj元素。
>
>   - removeAll(Collection coll1):差集：从当前集合中移除coll1中所有的元素。
>
>   - ```java
>     @Test
>     public void test3(){
>             //3.remove(Object obj):从当前集合中移除obj元素。
>             Collection coll = new ArrayList();
>             coll.add(123);
>             coll.add(456);
>             coll.add(new Person("Jerry",20));
>             coll.add(new String("Tom"));
>             coll.add(false);
>             coll.remove(123);
>             System.out.println(coll);//[456, Person{name='Jerry', age=20}, Tom, false]
>     
>             coll.remove(new Person("Jerry",20));
>             System.out.println(coll);//[456, Tom, false]
>     
>             //4. removeAll(Collection coll1):差集：从当前集合中移除coll1中所有的元素。
>             Collection coll1 = Arrays.asList(123,456);
>             coll.removeAll(coll1);
>             System.out.println(coll); //[Tom, false]
>     }
>     ```
>
> - 取两个集合的交集：boolean retainAll(Collection c)
>
>   - ```java
>     Collection coll = Arrays.asList(456,789);
>     Collection coll1 = Arrays.asList(123,456,789);
>     //5.retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合
>     coll.retainAll(coll1);
>     System.out.println(coll); //[456, 789]
>     ```
>
> - equals(Object obj):要想返回true，需要当前集合和形参集合的元素都相同。
>
> - hashCode():返回当前对象的哈希值
>
> - 集合转数组：toArray()
>
>   - ```java
>     Object[] arr = coll.toArray();
>     for(int i = 0;i < arr.length;i++){
>         System.out.println(arr[i]);
>     }
>     ```
>
> - 遍历iterator()
>
>   - ```java
>     Collection coll = new ArrayList();
>     coll.add(123);
>     coll.add(456);
>     coll.add(false);
>     Iterator iterator = coll.iterator();
>     ////hasNext():判断是否还有下一个元素
>     while(iterator.hasNext()){
>         //next():①指针下移 ②将下移以后集合位置上的元素返回
>         System.out.println(iterator.next());
>     }
>     ```

# Collection子接口之->List接口

> - [ ] 鉴于Java中数组用来存储数据的局限性,通常使用List替代数组。
> - [ ] List特点元素有序、且可重复,集合中的每个元素都有其对应的顺序索引。
> - [ ] List中的元素都对应一个整数型的序号记载其在容器中的位置,可以根据序号存取容器中的元素。
> - [ ] 常用实现类有:ArrayList、LinkedList和Vector。

## List接口之->ArrayList

>  * 是大小可变数组的实现,存储在内的数据称为元素.ArrayList 中可不断添加元素，其大小也自动增长。
>
>  * 特点是增删慢,查询快.是最常用的集合。
>
>  * ArrayList不能存储基本类型,基本数据类型对应的包装类型可以。
>
>  * 别什么需求都用ArrayList,并不严谨,这种用法是不提倡的。
>
>  * ```java
>    /**
>     * 当我们new ArrayList()并且第一次调用.add()方法的时候,底层会创建了一个Object[] elementData 并且指定长度为10。
>     * 当我们再次调用.add的时候,如果此次的添加导致底层elementData数组容量不够,则扩容。
>     * 默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。
>     */
>    ```

## List接口之->LinkedList

> *  LinkedList:双向链表,内部没有声明数组,而是定义了Node类型的first和last,用于记录首尾元素.
> *  同时,定义内部类Node,作为LinkedList中保存数据的基本结构。
> *  Node除了保存数据,还定义了两个变量：
>    *   prev变量记录前一个元素的位置
>    *   next变量记录下一个元素的位置
> *  特点是增删快,效率较高

## List接口之->Vector

> *  Vector大多数操作与ArrayList相同,区别之处在于Vector是线程安全的。

## ArrayList/LinkedList/Vector的异同?

> ArrayList和LinkedList的异同:
>
> * 二者都线程不安全,相对线程安全的Vector,执行效率高。
> * ArrayList是基于动态数组的数据结构,LinkedList是基于链表的数据结构。
> * 对于随机访问get和set,ArrayList觉得优于LinkedList,因为LinkedList要移动指针。
> * 对于新增和删除操作add(特指插入)和remove,LinkedList比较占优势,因为ArrayList要移动数据。
>
> ArrayList和Vector的区别:
>
> *  Vector和ArrayList基本差不多,区别在于Vector是同步类(synchronized)属于强同步类
>
> *  因此开销就比ArrayList要大,访问要慢。
> *  正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步可以自己控制
> *  Vector每次扩容请求其大小的2倍空间,而ArrayList是1.5倍

# Collection子接口之->Set

> 无序性:不是随机性,是你添加数据的时候不能按照数组索引的顺序添加,而是根据哈希值决定的
>
> 不可重复性:保证添加的元素按照equals判断时,不能返回true。就是相同元素只能填一次

## Set实现类HashSet

> 线程不安全，可以存储null值

## 向HashSet中添加元素的过程

> 当向HashSet中添加**元素A**时,首先调用**元素A**所在类的hashCode()方法,计算**元素A**的哈希值。
>
> 把**元素A**的哈希值按照某种算法来计算,从而算出**元素A**在HashSet底层数组中的所在位置(即为:**索引位置**)。
>
> 然后判断数组对应索引位置上是否已经存在了其他元素:{
>
> ​		如果此位置上没有其他元素,则**元素A**添加成功。  **(情况1)**
>
> ​		如果此位置上已有其他**元素B**(或者以链表形式存在的多个元素)时,则比较**元素A**与**元素B**的hash值:{
>
> ​				如果hash值不相同,则**元素A**添加成功。 (**情况2**)
>
> ​				如果hash值相同,进而需要调用元素A所在类的equlas()方法:
>
> ​					返回true**元素A**添加失败,
>
> ​					返回false,**元素A**添加成功。(**情况3**)
>
> ​		}
>
> }
>
> 对于添加元素成功的情况2和3而言:**元素A**与已经在索引位置上存在的数据以链表的方式存储。
>
> 链表存储格式在jdk7中：元素A放到数组中,指向原来的元素。
>
> 链表存储格式在jdk8中：原来的元素放在数组中,指向A。
>
> 好记忆就是**七上八下**。
>
> 扩容机制:初始容量为16,如果使用率超过0.75(16*0.75=12),就会扩大为原来的2倍(16,32,64,128)。
>
> 注意:向set中添加的数据,其所在的类一定要重写hashCode和equlas方法。
>
> ​		 重写的hashCode和equlas尽可能保持一致，相等的对象必须具有相等的散列值
>
> ​		 重写两个方法的小技巧:对象中用作equals()方法比较的Field,都应该用来计算hashCode()

## Set实现类之LinkedHashSet

> LinkedHashSet是HashSet 的子类,在添加数据的同时,每个数据还维护了两个引用,记录此数据前一个数据和后一个数据。
>
> 优点:遍历内部数据时,可以按照添加的顺序去遍历,对应比较频繁的遍历操作LinkedHashSet性能高于HashSet。

## Set实现类之TreeSet

> 可以按照添加对象的指定属性进行排序
>
> 1.像treeSet中添加的数据,要求是相同类的对象。
>
> 2.如果试图把一个对象添加到TreeSet时,则该对象的类必须实现Comparable接口,实现compareTo(Object obj) 方法
>
> 3.Comparable的典型实现:
>
> ​	  3.1.BigDecimal,BigInteger以及所有的数值型对应的包装类:按它们对应的数值大小进行比较。
>
> ​	  3.2.Character:按字符的 unicode值来进行比较。
>
> ​	  3.3.Boolean:true 对应的包装类实例大于 false 对应的包装类实例。
>
> ​	  3.4.String:按字符串中字符的 unicode 值进行比较。
>
> ​	  3.5.Date,Time:后边的时间、日期比前面的时间、日期大。
>
> 4.排序:
>
> ```java
> /**
>  * 自然排序
>  * 向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。
>  * 因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象。
>  * 对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值。
>  * 当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保
>  * 证该方法与 compareTo(Object obj) 方法有一致的结果：如果两个对象通过
>  * equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0。否则，让人难以理解。
>  *
>  * 定制排序
>  *  TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没
>  * 有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照
>  * 其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来
>  * 实现。需要重写compare(T o1,T o2)方法。
>  *  利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表
>  * 示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。
>  *  要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构
>  * 造器。
>  *  此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异
>  * 常。
>  *  使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。
>  */
> ```

# 面试题

## 集合Collection中存储的如果是自定义类的对象，需要自定义类重写哪个方法？为什么？

> - List：equals()方法 
>   - 不重写equals没办法比较是否相等啊，好多方法都是调用equals来判断的
> - HashSet、LinkedHashSet：equals()、hashCode()
>   - 因为HashSet底层是根据hash值来计算索引位置的,以及来实现去重的
> - TreeSet：equals()、Comparable:compareTo()、Comparator:compare()
>   - TreeSet判断两个对象是否相等的唯一标准是:两个对象通过compareTo(Object obj) 方法比较返回值；
>   - 如果把自定义对象放入TreeSet时,重写该对象对应的equals(),保证该方法与 compareTo(Object obj) 方法有一致的结果：如果两个对象通过equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0。否则，-1。

## 简述常见的数据结构中元素的存取特点

```java
/**
 * 栈：stack，又称堆栈，对元素的存取特点是：先进后出。即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素。
 * 队列：queue，简称队，对元素的存取特点是：先进先出。即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素。
 * 数组:Array，是有序的元素序列，对元素的存取特点是：
 *      1、查找元素快：通过索引，可以快速访问指定位置的元素
 *      2、增删元素慢
 *          （1）指定索引位置增加元素:需要创建一个新数组,将指定新元素存储在指定索
 *               引位置,再把原数组元素根据索引,复制到新数组对应索引的位置。
 *          （2）指定索引位置删除元素:需要创建一个新数组,把原数组元素根据索引，
 *              复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。
 * 链表:linked list,对元素的存取有如下的特点：
 *      1、多个结点之间,通过地址进行连接。
 *          例如,多个人手拉手,每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。
 *      2、查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。
 *      3、增删元素快：
 *          增加元素：只需要修改连接下个元素的地址即可。
 *          删除元素：只需要修改连接下个元素的地址即可。
 */
```

## 数据结构

数据存储的常用结构有：栈、队列、数组、链表和红黑树

![image-20200606101111389](C:\Users\Administrator.DESKTOP-8F1MHB5\Desktop\2020.03.24\基础\image\image-20200606101111389.png)

![image-20200606101457954](C:\Users\Administrator.DESKTOP-8F1MHB5\Desktop\2020.03.24\基础\image\image-20200606101457954.png)

![image-20200606101835927](C:\Users\Administrator.DESKTOP-8F1MHB5\Desktop\2020.03.24\基础\image\image-20200606101835927.png)

![image-20200606102039399](C:\Users\Administrator.DESKTOP-8F1MHB5\Desktop\2020.03.24\基础\image\image-20200606102039399.png)

![image-20200606102232890](C:\Users\Administrator.DESKTOP-8F1MHB5\Desktop\2020.03.24\基础\image\image-20200606102232890.png)

# 

## 简述Comparable和Comparator两个接口的区别

> Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。
>
> 
>
> Comparator强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。

# Map

> Map存储结构的理解：
>
> > key:是无序的,不可重复的,使用Set存储所有的key,key所在的类要重写equals()和hashCode()(HashMap例)
> >
> > value:无序的,可重复的,使用Collection存储所有的value,value所在的类要重写equals()
> >
> > key和value构成了一个Entry对象。
> >
> > Entry:无序的,不可重复的,使用Set存储所有的entry

## HashMap

> 线程不安全的,效率高:key和value可以为null。

## LinkedHashMap

> 可以按照添加时的顺序实现遍历。
>
> 因为在HashMap底层结构基础上,添加了一对指针,指向前一个和后一个元素。
>
> 对于频繁的遍历操作,此类执行效率高于HashMap。

## TreeMap

> 可以按照key-value进行排序。
>
>  *              有自然排序(Comparable.compareTo())
>  *              定制排序(Comparator.compare()).
>  *              底层使用红黑树

## Hashtable

> 线程安全的,效率低;不能存储null的key和value,常用来处理配置文件key和value都是String类型

## HashMap的底层实现原理？

> HashMap在jdk7中实现原理:数组+链表
>
> - HashMap map = new HashMap():在实例化以后,底层创建了长度是16的一维数组Entry[] table。
> - map.put(key1,value1)时:
>   - 首先,调用key1所在类的hashCode()计算key1哈希值，
>   - 此哈希值经过某种算法计算以后，
>   - 得到在Entry数组中的存放位置。
>   - 如果此位置上的数据为空,此时的key1-value1添加成功。(**情况1**)
>   - 如果此位置上的数据不为空，(意味着此位置上存在一个或多个以链表形式存在数据),比较key1和已经存在的一个或多个数据的哈希值：
>     - 如果key1的哈希值与已经存在的数据的哈希值都不相同,此时key1-value1添加成功。(**情况2**)
>     - 如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：
>       - 如果equals()返回false:此时key1-value1添加成功。(**情况3**)
>       - 如果equals()返回true:使用value1替换value2。
> - 如果你多次put后key1-value1和原来的数据以链表的方式存储(情况2和情况3)
> - 在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。
> - 默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。
>
> HashMap在jdk8中相较于jdk7在底层实现方面的不同：
>
> - new HashMap():底层没创建一个长度为16的数组
> - jdk 8底层的数组是：Node[],而非Entry[]
> - 首次调用put()方法时，底层创建长度为16的数组
> - jdk7底层结构：数组+链表。jdk8中底层结构：数组+链表+红黑树。
> - 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）
> - 当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且当前数组的长度 > 64时，此时此索引位置上的所数据改为使用红黑树存储。

# 如何遍历map容器,获取key->value

```java
//遍历所有的key-value
Map map = new HashMap();
map.put("AA", 123);
map.put(45, 1234);
map.put("BB", 56);
//方式一：entrySet()
Set entrySet = map.entrySet();
Iterator iterator1 = entrySet.iterator();
while (iterator1.hasNext()) {
    Object obj = iterator1.next();
    //entrySet集合中的元素都是entry
    Map.Entry entry = (Map.Entry) obj;
    System.out.println(entry.getKey() + "---->" + entry.getValue());

}
System.out.println();
//方式二：
Set keySet = map.keySet();
Iterator iterator2 = keySet.iterator();
while (iterator2.hasNext()) {
    Object key = iterator2.next();
    Object value = map.get(key);
    System.out.println(key + "=====" + value);
}
```

# Collection 和 Collections的区别？

> Collection是一个接口子类有list set
>
> Collections是一个工具类里面提供了一些静态方法

# IO流

# Java中有几种类型的流？

字符流和字节流和转换流与对象流(序列化使得)缓冲流

# 字符流和字节流有什么区别？

> 字节流的操作不会经过缓冲区而是直接操作文本本身的，而字符流的操作会先经过缓冲区然后通过缓冲区再操作文件

# 什么是缓冲区？有什么作用？

> - [ ] 缓冲区就是一段特殊的内存区域，很多情况下当程序需要频繁地操作一个资源（如文件或数据库）则性能会很低，所以为了提升性能就可以将一部分数据暂时读写到缓存区，以后直接从此区域中读写数据即可，这样就显著提升了性。
> - [ ] 对于 Java 字符流的操作都是在缓冲区操作的，所以如果我们想在字符流操作中主动将缓冲区刷新到文件则可以使用 flush() 方法操作。

# 什么是Java序列化，如何实现Java序列化？

> - 就是把对象转化为流的一种机制,可以对流化后的对象进行读写操作,也可将流化后的对象传输于网络之间。
> - 是为了解决在对对象流进行读写操作时所引发的问题。
>   - 就是我有个对象实现Serializable 然后来个属性serialVersionUID = 1L 的版本号。
>   - 然后我想把对象的保存到文件里。 
>   - 这时候我new一个 **文件流** 告诉说我要存哪里。
>   - 然后我把 **文件流** 往 **输出流** 里一扔，把内容写进去，一保存。我就把对象保存起来了。
>   - 然后我再来个 **对象输入流** 把保存那个文件读出来给我个Object我一强转。哎我就可以正常用了不是。

# 序列化和反序列化

Java 通过对象输入输出流来实现序列化和反序列化：

序列化：`java.io.ObjectOutputStream` 类的 `writeObject()` 方法可以实现序列化；

反序列化：`java.io.ObjectInputStream` 类的 `readObject()` 方法用于实现反序列化。

```java

public class SerializeDemo01 {
 
    enum Sex {
 
        MALE, FEMALE
 
    }
 
    static class Person implements Serializable {
 
        private static final long serialVersionUID = 1L;
 
        private String name = null;
 
        private Integer age = null;
 
        private Sex sex;
 
        public Person() {
 
            System.out.println("call Person()");
 
        }
 
        public Person(String name, Integer age, Sex sex) {
 
            this.name = name;
 
            this.age = age;
 
            this.sex = sex;
 
        }
 
        public String toString() {
 
            return "name: " + this.name + ", age: " + this.age + ", sex: " + this.sex;
 
        }
 
    }
 
    /**
     * 序列化
     */
 
    private static void serialize(String filename) throws IOException {
 
        File f = new File(filename); // 定义保存路径
 
        OutputStream out = new FileOutputStream(f); // 文件输出流
 
        ObjectOutputStream oos = new ObjectOutputStream(out); // 对象输出流
 
        oos.writeObject(new Person("Jack", 30, Sex.MALE)); // 保存对象
 
        oos.close();
 
        out.close();
 
    }
 
    /**
     * 反序列化
     */
 
    private static void deserialize(String filename) throws IOException, ClassNotFoundException {
 
        File f = new File(filename); // 定义保存路径
 
        InputStream in = new FileInputStream(f); // 文件输入流
 
        ObjectInputStream ois = new ObjectInputStream(in); // 对象输入流
 
        Object obj = ois.readObject(); // 读取对象
 
        ois.close();
 
        in.close();
 
        System.out.println(obj);
 
    }
 
    public static void main(String[] args) throws IOException, ClassNotFoundException {
 
        final String filename = "io流\\text.dat";
 
        serialize(filename);
 
        deserialize(filename);
 
    }
 
}
```

# serialVersionUID

> -  `serialVersionUID` 是Java为每个序列化类产生的版本标识。
>
> - 它可以用来保证在反序列时，发送方发送的和接受方接收的是可兼容的对象。
>
> - 如果接收方接收的类的 `serialVersionUID` 与发送方发送的 `serialVersionUID` 不一致，会抛出 `InvalidClassException`。
>
>   ---
>
> - 如果在类中你没写,那么它的值是Java运行时根据类的内部细节自动生成的。
>
> - 类的实例变量做了修改，serialVersionUID 可能发生变化。
>
> - 不同的 jdk 编译也可能会生成不同的 `serialVersionUID` 默认值。
>
> - 故建议，显式声明（写上把还是）。
>
> - **`serialVersionUID` 字段必须是 `static final long` 类型**。

# 默认序列化机制

> 在序列化对象时，不仅会序列化当前对象本身，还会对其父类的字段以及该对象引用的其它对象也进行序列化。
>
> 同样地，这些其它对象引用的另外对象也将被序列化，以此类推。
>
> 所以，如果一个对象包含的成员变量是容器类对象，而这些容器所含有的元素也是容器类对象，那么这个序列化的过程就会较复杂，开销也较大。
>
> 注意：这里的父类和引用对象既然要进行序列化，那么它们当然也要满足序列化要求：**被序列化的类必须属于 Enum、Array 和 Serializable 类型其中的任何一种**。

# 非默认序列化机制

## transient 关键字

> 当某个字段被声明为 transient 后，默认序列化机制就会忽略该字段

## Externalizable 接口

就知道具体没用过

# 谈谈你对Serializable接口的理解,我们知道它用于序列化，是空方法接口，还有其它认识吗？

> - [ ] 实现了Serializable 接口的对象,可将它们转换成一系列字节,并可在以后完全恢复回原来的样子。 
> - [ ] 这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。
> - [ ] 在 换句话说，可以先在Windows 机器上创建一个对象，对其序列化。
> - [ ] 然后通过网络发给一台Unix 机器，然后在那里准确无误地重新“装配”。
> - [ ] 不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。
> - [ ] 由于大部分作为参数的类如String 、Integer 等都实现了Serializable 的接口，也可以利用多态的性质，作为参数使接口更
>   灵活

# 什么是反射?

> 反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息,并能直接操作任意对象的内部属性及方法。
>
> 加载完类之后,在堆内存的方法区中就产生了一个Class类型的对象,这个对象就包含了完整的类的结构信息。
>
> 我们可以通过这个对象看到类的结构。
>
> 这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射

# 为什么要用反射?

> - 动态语言
>   - Object-C、C#、JavaScript、PHP、Python在运行时代码可以根据某些条件改变自身结构。
> - 静态语言
>   - 与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。
> - Java不是动态语言，但Java可以称之为“准动态语言”。我们可以利用反射机制、字节码操作获得类似动态语言的特性。
>   Java的动态性让编程的时候更加灵活！
> - Java 反射机制提供的功能
>   - 在运行时判断任意一个对象所属的类
>   - 在运行时构造任意一个类的对象
>   - 在运行时判断任意一个类所具有的成员变量和方法
>   - 在运行时获取泛型信息
>   - 在运行时调用任意一个对象的成员变量和方法
>   - 在运行时处理注解
>   - 生成动态代理

# 谈谈你对java.lang.Class类的理解

> - 1.类的加载过程：
>   - 程序经过javac.exe(编译)命令以后，会生成一个或多个字节码文件(.class结尾)。
>     - 1.编译:javac Party.java
>   - 接着我们使用java.exe(运行)命令对某个字节码文件进行解释运行。
>     - 2.运行:java Party
>   - 相当于将某个字节码文件加载到内存中。
>   - 此过程就称为类的加载。
>   - 加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。
> - 换句话说，Class的实例就对应着一个运行时类。
> - 加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式
>   来获取此运行时类。

# 获取Class实例的三种常见方式

> - 方式一：调用运行时类的属性：.class
>
>   - ```java
>     Class clazz1 = Person.class;
>     System.out.println(clazz1);
>     ```
>
> - 方式二：通过运行时类的对象,调用getClass()
>
>   - ```java
>     Person p1 = new Person();
>     Class clazz2 = p1.getClass();
>     System.out.println(clazz2);
>     ```
>
> - 方式三：调用Class的静态方法：forName(String classPath)
>
>   - ```java
>     Class clazz3 = Class.forName("com.atguigu.java.Person");
>     System.out.println(clazz3);
>     ```
>
> - 方式四：使用类的加载器：ClassLoader  (了解)
>
>   - ```java
>     ClassLoader classLoader = ReflectionTest.class.getClassLoader();
>     Class clazz4 = classLoader.loadClass("com.atguigu.java.Person");
>     System.out.println(clazz4);
>     ```

# (false)类的加载(ClassLoader)过程

> - 当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。
> - Load:类的加载
>   - 将class文件字节码内容加载到内存中,并将这些静态数据转换成方法区的运行时数据结构,
>   - 然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。
>   - 所有需要访问和使用类数据只能通过这个Class对象。
>   - 这个加载的过程需要类加载器参与。
> - Link:类的链接
>   - 将Java类的二进制代码合并到JVM的运行状态之中的过程。
>   - 验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题
>   - 准备：正式为类变量（static）分配内存并 设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。
>   - 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。
> - Initialize:类的初始化
>   - 执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中
>     所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信
>     息的，不是构造该类对象的构造器）。
>   - 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类
>     的初始化。
>   - 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。
> - 什么 时候会发生类初始化 ？
>   -  类的主动引用 （ 一定会发生类的初始化 ）
>     - 当虚拟机启动，先初始化main方法所在的类
>     - new一个类的对象
>     - 调用类的静态成员（除了final常量）和静态方法
>     - 使用java.lang.reflect包的方法对类进行反射调用
>     - 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类
>   - 类的被动引用 （ 不会发生类的初始化 ）
>     - 当访问一个静态域时，只有真正声明这个域的类才会被初始化。当通过子类引用父类的静态变量，不会导致子类初始化
>     - 通过数组定义类引用，不会触发此类的初始化
>     - 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）
> - ClassLoader类加载器的作用：
>   - 类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方
>     法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为
>     方法区中类数据的访问入口。
>   - 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器
>     中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。

# 通过反射，创建运行时类的对象

newInstance()

```java
//有参构造
Class clazz = Personss.class;
//1.通过反射，创建Person类的对象
Constructor cons = clazz.getConstructor(String.class,int.class);
Object obj = cons.newInstance("Tom", 12);

//无参构造
Class<Personss> clazz = Personss.class;
Personss obj = clazz.newInstance();
```

# 并行与并发

并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。
并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。

# 创建线程有哪些方式

- 继承thread类,重写run方法,调用start。
- 实现Runnable接口,重写run方法,调用start。
- 实现Callable接口,传递泛型,重写call方法。
- 使用线程池。
- run()方法由JVM调用,什么时候调用由CPU调度决定。
- 多个线成只能调用一次start否则抛出异常java.lang.IllegalThreadStateException。

# 为什么要使用线程池

- 提前创建多个线程,放入线程池中,使用时直接获取,使用完放回池中。可以避免频繁创建销毁、实现重复利用。
  - 减少了创建新线程的时间（提高响应速度）。
  - 重复利用线程池中线程，不需要每次都创建（降低资源消耗）。
  - 便于线程管理比如:
    - 核心池的大小：corePoolSize
    - 最大线程数：maximumPoolSize
    - 线程没有任务时最多保持多长时间后会终止：keepAliveTime
- 常见工具类有:
  - Executors.newCachedThreadPool():创建一个可根据需要创建新线程的线程池
  - Executors.newFixedThreadPool(n):创建一个可重用固定线程数的线程池
  - Executors.newSingleThreadExecutor():创建一个只有一个线程的线程池
  - Executors.newScheduledThreadPool(n):创建一个线程池,可延迟执行或者定期执行。

# 实现Runable,Callable与继承Thread比较

> - 1.java中存在的单继承多实现机制
> - 2.接口代码可以被多个线程共享，代码和线程独立。
> - 3.线程池只能放Runable或Callable不能直接放入继承Thread的类。
> - 4.在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。

# Runnable和Callable接口比较

```java
/**
 相同点：
 	都是接口,都可以完成多线程,都得调用Thread.start()启动线程；
 不同点：
 	1.Callable有返回值；Runnable没有返回值；
 	2.Callable可以抛异常[call()]；Runnable不可以抛异常[run()]；
 	3.Callable可以取消执行(Future.cancel),Runnable不能
 注意点：
 	Callable支持返回值，需要调用FutureTask.get()实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！
 */
```

# 线程安全问题

> * 1.同步代码块
>   *      锁对象,当前对象字节码,成员变量都可以
> * 2.同步方法
>   *      非static方法,同步锁是this.static方法,使用当前方法所在类的字节码对象(类名.class)
> * 3.Lock锁功能强大更体现面向对象 加锁与释放锁方法化

### 问题演示

```java
public class newTicket implements Runnable {
    private int ticktNum = 10;
    @Override
    public void run() {
        while(true) {
                if (ticktNum > 0) {
                    //1.模拟出票时间
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    //2.打印进程号和票号，票数减1
                    String name = Thread.currentThread().getName();
                    System.out.println("线程" + name + "售票：" + ticktNum--);
                }
            }
    }
}
public class newTicketDemo {
    public static void main(String[] args){
        newTicket ticket = new newTicket();
        Thread thread1 = new Thread(ticket, "窗口1");
        Thread thread2 = new Thread(ticket, "窗口2");
        Thread thread3 = new Thread(ticket, "窗口3");

        thread1.start();
        thread2.start();
        thread3.start();
    }
}
/**
 * 线程窗口1售票：10
 * 线程窗口3售票：9
 * 线程窗口2售票：8
 * 线程窗口1售票：7
 * 线程窗口3售票：6  问题吖
 * 线程窗口2售票：6  问题吖
 * 线程窗口3售票：5  问题吖
 * 线程窗口2售票：4
 * 线程窗口1售票：5  问题吖
 * 线程窗口2售票：2
 * 线程窗口1售票：1
 * 线程窗口3售票：3
 */
```

### 解决方式-线程同步

同步代码:块最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着

```java
public class newTicket implements Runnable {

    private int ticktNum = 10;
    Object obj = new Object(); //锁对象 锁的钥匙 索谁还不行 当前对象字节码 锁成员变量
    
    @Override
    public void run() {
        synchronized (obj) {
            while(true) {
                if (ticktNum > 0) {
                    //1.模拟出票时间
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    //2.打印进程号和票号，票数减1
                    String name = Thread.currentThread().getName();
                    System.out.println("线程" + name + "售票：" + ticktNum--);
                }
            }
        }
    }
}
```

同步方法:synchronized修饰的方法,保证A线程执行该方法的时候,其他线程只能在方法外等着

对于非static方法,同步锁就是this.对于static方法,我们使用当前方法所在类的字节码对象(类名.class)		 

```java
public class newTicket implements Runnable {

    private int ticktNum = 10;
    @Override
    public void run() {
        while (true) {
            sellTicket();
        }
    }
    /**
     * 方法标注
     * 如果是静态方法,锁对象相当于
     * private static synchronized(newTicket.class) void sellTicket()
     * 如果不是静态方法，锁对象相当于
     * private  synchronized(new newTicket()) void sellTicket()
     */
    private synchronized void sellTicket() {
        if (ticktNum > 0) {
            //1.模拟出票时间
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //2.打印进程号和票号，票数减1
            String name = Thread.currentThread().getName();
            System.out.println("线程" + name + "售票：" + ticktNum--);
        }
    }
}
```

同步锁lock:功能强大更体现面向对象 加锁与释放锁方法化

```java
//public void lock():加同步锁
//public void unlock():释放同步锁
public class newTicket implements Runnable {
    private int ticktNum = 10;
    /**
     * 3.同步锁
     * 定义锁对象：构造函数参数为线程是否公平获取锁true-公平；
     * false-不公平，即由某个线程独占，默认是false
     */
    Lock lock = new ReentrantLock(true);
    public void run() {
        while(true){
            lock.lock(); //加锁
            try{
                if(ticktNum > 0){
                    //1.模拟出票时间
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    //2.打印进程号和票号，票数减1
                    String name = Thread.currentThread().getName();
                    System.out.println("线程"+name+"售票："+ticktNum--);
                }
            } finally {
                lock.unlock(); //放锁
            }
        }
    }
}
```

### Synchronized和Lock区别

*   synchronized不能判断锁的状态,Lock可以判断是否获取到锁；
*   synchronized会在执行完毕或者抛出异常的时候自动释放锁，
    *   Lock需要调用unlock()释放锁,否则容易造成死锁；
*   用synchronized修饰的方法和代码块。
    *   线程A获得锁,线程b等待。
    *   线程A阻塞,线程B一直等待下去。
    *   而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了。
*   大量同步用Lock,少量用synchronized

# 线程生命周期

> - 新建: 创建(Thread t = new MyThread())了一个线程 
> - 就绪:调用了start()方法 
>   - 线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行
> - 运行:运行run()方法
>   - 就绪是进入到运行状态的唯一入口,线程要想进入运行状态执行,首先必须处于就绪状态中
> - 阻塞:睡眠(sleep),等待通知（notify）
>   - 阻塞又分三种
>     - a.等待阻塞:线程执行wait()方法,使本线程进入到等待阻塞状态。
>      - b.同步阻塞:获取synchronized同步锁失败(因为锁被其它线程所占用),它会进入同步阻塞状态。
>     - c.其他阻塞:通过调用线程的sleep()或join()或发出了I/O请求时,线程会进入到阻塞状态。
>       - 当sleep()状态超时、
>       - join()等待线程终止或者超时、
>        - 或者I/O处理完毕时，
>       - 线程重新转入就绪状态。
>  - 死亡:线程执行完了或者因异常退出了run()方法，该线程结束生命周期

# 什么是死锁

> 两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。
>
> 结果就是两个进程都陷入了无限的等待中

# 如何避免线程死锁?

> 预防死锁是设法破坏产生死锁的四个必要条件之一
>
> - 破坏互斥条件,
> - 破坏占有并等待条件,
> - 破坏不可抢占条件,
> - 破坏循环等待条件

# 线程通讯

> - 多个线程并发执行时,默认情况CPU是随机切换线程的,有时我们希望CPU按我们的规律执行线程,此时就需要线程通讯。
> - Object的wait(进入等待状态),notify(唤醒),notifyAll(唤醒所有)
>   - wait与notify必须是同一个锁对象.
>   - 锁对象可以是任意对象,因为wait,notify属于Object类的方法,所有类都继承Object类。
>   - wait与notify必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。
>   - wait只能通过Nodify,notifyAll方法进行唤醒
> - Condition的await、signal、signalAll
>   - await()必须和Lock(互斥锁/共享锁)配合使用
>   - await()必须通过signal(),signalAll()方法进行唤醒
> - 并发工具类
>   - CountDownLatch：线程A等待其他线程执行完在执行
>   - CyclicBarrier：一组线程等待至某个状态之后再全部同时执行
>   - Semaphore：用于控制对某组资源的访问权限

案例:生产者与消费者(生产包子吃包子),打印基偶数

```java
/**
 * 线程通讯
 * 1.Object的wait(进入等待状态),notify(唤醒),notifyAll(唤醒所有)
 *  细节:
 *      1.wait与notify必须是同一个锁对象.
 *      2.锁对象可以是任意对象,因为wait,notify属于Object类的方法,所有类都继承Object类。
 *      3.wait与notify必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。
 *      4.wait只能通过Nodify,notifyAll方法进行唤醒
 * 2.Condition的await、signal、signalAll
 *  细节:
 *      1.await()必须和Lock(互斥锁/共享锁)配合使用
 *      2.await()必须通过signal(),signalAll()方法进行唤醒
 * 3.并发工具类
 * 3.1.CountDownLatch：用于某个线程A等待若干个其他线程执行完之后，它才执行
 * 3.2.CyclicBarrier：一组线程等待至某个状态之后再全部同时执行
 * 3.3.Semaphore：用于控制对某组资源的访问权限
 */
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.Semaphore;
import java.util.Date;
//Object的wait,notify,notifyAll
public class ObjectWaitNotifyRunnable {
    private Object obj = new Object();
    private Integer i = 0;

    public void odd() {
        while (i < 10) {
            synchronized (obj) {
                if (i % 2 == 1) {
                    System.out.println("奇数：" + i);
                    i++;
                    obj.notify();
                } else {
                    try {
                        obj.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    public void even() {
        while (i < 10) {
            synchronized (obj) {
                if (i % 2 == 0) {
                    System.out.println("偶数：" + i);
                    i++;
                    obj.notify();
                    obj.notifyAll();
                } else {
                    try {
                        obj.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    public static void main(String[] args) {
        final ObjectWaitNotifyRunnable runnable = new ObjectWaitNotifyRunnable();
        Thread t1 = new Thread(new Runnable() {
            public void run() {
                runnable.odd();
            }
        }, "偶数线程");
        Thread t2 = new Thread(new Runnable() {
            public void run() {
                runnable.even();
            }
        }, "奇数线程");

        t1.start();
        t2.start();
    }
}

//==================================================================================
//Condition的await、signal、signalAll
class ConditionWaitNotifyRunnable {
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    private Integer i = 0;

    public void odd() {
        while (i < 10) {
            lock.lock();
            try {
                if (i % 2 == 1) {
                    System.out.println("奇数：" + i);
                    i++;
                    condition.signal();
                } else {
                    condition.await();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    public void even() {
        while (i < 10) {
            lock.lock();
            try {
                if (i % 2 == 0) {
                    System.out.println("偶数：" + i);
                    i++;
                    condition.signal();
                } else {
                    condition.await();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }
    }

    public static void main(String[] args) {
        ConditionWaitNotifyRunnable runnable = new ConditionWaitNotifyRunnable();
        Thread t1 = new Thread(new Runnable() {
            public void run() {
                runnable.odd();
            }
        }, "偶数线程");
        Thread t2 = new Thread(new Runnable() {
            public void run() {
                runnable.even();
            }
        }, "奇数线程");

        t1.start();
        t2.start();
    }
}

//==================================================================================
//CountDownLatch

/**
 * 1.CountDownLatch是在java1.5被引入的，存在于java.util.concurrent包下。
 * 2.CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。
 * 3.CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量
 * 4.每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，
 * 它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。
 */
class CountDown {
    private Integer i = 0;
    private CountDownLatch countDownLatch = new CountDownLatch(1);

    public void odd() {
        while (i < 10) {
            if (i % 2 == 1) {
                System.out.println("奇数：" + i);
                i++;
                countDownLatch.countDown();
            } else {
                try {
                    countDownLatch.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public void even() {
        while (i < 10) {
            if (i % 2 == 0) {
                System.out.println("偶数：" + i);
                i++;
                countDownLatch.countDown();
            } else {
                try {
                    countDownLatch.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        final CountDown countDown = new CountDown();
        Thread t1 = new Thread(new Runnable() {
            public void run() {
                countDown.odd();
            }
        }, "奇数");
        Thread t2 = new Thread(new Runnable() {
            public void run() {
                countDown.even();
            }
        }, "偶数");

        t1.start();
        t2.start();
    }
}

//=======================================================================================================================
//CyclicBarrier方式

/**
 * CyclicBarrier是在java1.5被引入的，存在于java.util.concurrent包下。
 * CyclicBarrier实现让一组线程等待至某个状态之后再全部同时执行。
 * CyclicBarrier底层是三个线程同时启动
 */
class CyclicBarrierDemo {
    public static void main(String[] args) {
        final CyclicBarrier cyclicBarrier = new CyclicBarrier(3);

        new Thread(new Runnable() {
            public void run() {
                System.out.println(Thread.currentThread().getName() + "：准备...");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "启动完毕：" + new Date().getTime());
            }
        }, "线程1").start();
        new Thread(new Runnable() {
            public void run() {
                System.out.println(Thread.currentThread().getName() + "：准备...");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "启动完毕：" + new Date().getTime());
            }
        }, "线程2").start();
        new Thread(new Runnable() {
            public void run() {
                System.out.println(Thread.currentThread().getName() + "：准备...");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "启动完毕：" + new Date().getTime());
            }
        }, "线程3").start();
    }
}

//==========================================================================================================================
//Semaphore方式

/**
 * Semaphore是在java1.5被引入的，存在于java.util.concurrent包下。
 * Semaphore用于控制对某组资源的访问权限。工人使用机器工作
 */
class SemaphoreDemo {

    static class Machine implements Runnable {
        private int num;
        private Semaphore semaphore;

        public Machine(int num, Semaphore semaphore) {
            this.num = num;
            this.semaphore = semaphore;
        }

        public void run() {
            try {
                semaphore.acquire();//请求机器
                System.out.println("工人" + this.num + "请求机器，正在使用机器");
                Thread.sleep(1000);
                System.out.println("工人" + this.num + "使用完毕，已经释放机器");
                semaphore.release();//释放机器
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        int worker = 8;//工人数
        Semaphore semaphore = new Semaphore(3);//机器数
        for (int i = 0; i < worker; i++) {
            new Thread(new Machine(i, semaphore)).start();
        }
    }
}
```

# sleep和wait区别

> - 同步 
>   - wait只能在同步代码块中使用,否则抛出异常
>   - 不需要在同步方法或同步代码块中调用
> - 作用对象
>   - wait方法定义在obj类中，作用与对象本身
>   - sleep方法定义在thread中，作用与当前线程
> - 释放锁资源
>   - wait释放,sleep不释放
> - 唤醒条件
>   - 调用notity或者notityall方法
>   - 超时或者调用interrupt方法体
> - 方法属性
>   - wait是实例方法
>   - sleep是静态方法

# wait和notify区别

一个等待一个唤醒嘛

# 并发编程三要素,多线程特性？

```java
/**
 * 多线程编程要保证满足三个特性：
 * 1）原子性-> 原子性指的是一个或者多个操作，
 *            要么全部执行并且在执行的过程中不被其他操作打断，
 *            要么就全部都不执行。
 * 2）可见性-> 可见性指多个线程操作一个共享变量时，
 *            其中一个线程对变量进行修改后，
 *            其他线程可以立即看到修改的结果。
 * 3）有序性-> 有序性，即程序的执行顺
 *            序按照代码的先后顺序来执行。
 */
```

# 线成控制类-ThreadLocal

>  * 描述:
>    * 当数据是以线程为作用域并且不同线程具有不同的数据副本的时候,可以采用ThreadLocal.
>    * 比如数据库连接Connection,web开发中参数传递,每个请求处理线程都需要，但又不相互影响。
>  * 原理
>    * 1.在ThreadLocal类中有一个ThreadLocalMap，
>    * 2.每一个Thread都有一个ThreadLocalMap类型的变量threadLocals
>    * 3.threadLocals内部有一个Entry，Entry的key是ThreadLocal对象实例，value就是共享变量副本
>    * 4.ThreadLocal的get方法就是根据ThreadLocal对象实例获取共享变量副本
>    * 5.ThreadLocal的set方法就是根据ThreadLocal对象实例保存共享变量副本

# 原子类-原子类解决非原子性操作问题

```java
/**
 * 一.Java的java.util.concurrent.atomic包里面提供了很多可以进行原子操作的类，分为以下四类：
 * 1.基本类型：AtomicInteger、AtomicBoolean、AtomicLong
 * 2.数组：AtomicIntegerArray、AtomicLongArray
 * 3.引用：AtomicReference、AtomicStampedReference等
 * 4.属性：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater
 * 提供这些原子类的目的就是为了解决基本类型操作的非原子性导致在多线程并发情况下引发的问题。
 */
```

# CAS相关

> - 什么是CAS
>   - CAS意思就是比较交换,乐观锁(如给记录加version来获取数据,性能较悲观锁有很大的提高。)
> - 原理
>   - AtomicInteger、AtomicBoolean 先对应方法
>     - (n++)  n.getAndIncrement()
>     - (++n)  n.incrementAndGet()
>     - (--n)   n.decrementAndGet() 
>     - (n--)   n.getAndDecrement(); 
>   - 方法getAndAddInt,getAndAddLong中代码大概意思如下
>     - 判断当前值和预期值是否相同。
>     - 相同认为没有线程更改过该值
>     - 不相同说明有线程更改过该值
> - CAS的问题
>   - CAS容易造成ABA问题
>     - 当前内存的值一开始是A，被另外一个线程先改为B然后再改为A，
>     - 那么当前线程访问的时候发现是A，cas则认为它没有被其他线程访问过。
>     - 在某些场景下这样是存在错误风险的（狸猫换太子）
>   - CAS造成CPU利用率增加
>     - CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu资源会一直被占用
>   - 不能保证代码块的原子性
>     - CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。
>     - 比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized了
> - CAS的ABA问题及解决
>   - AtomicStampedReference

# volatile关键字的作用

> 1.对于可见性，Java提供了volatile关键字来保证可见性。
>
> 2.当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，
>
> 当有其他线程需要读取时，它会去内存中读取新值。
>
> 3.volatile的一个重要作用就是和CAS结合，保证了原子性比如AtomicInteger。
>
> 4.volatile只能保证可见性，不能保证原子性

# 实现可见性的方法有哪些？

> synchronized或者Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放之前把最新的值刷新到主内存，实现可见性。

# 线程B怎么知道线程A修改了变量

> volatile修饰变量
> synchronized修饰修改变量的方法
> object的wait/notify
>
> Condition的await、signal
>
> while轮询

# synchronized、volatile、CAS比较

> synchronized是悲观锁，属于抢占式，会引起其他线程阻塞。
> volatile提供多线程共享变量可见性和禁止指令重排序优化。
> CAS是基于冲突检测的乐观锁（非阻塞）

# 同步方法和同步块，哪个是更好的选择?

> 同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。