# 介绍 nginx 的应用场景和具体可以做什么事情

> - 正向代理
>   - Nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。
>   - 正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，
>   - 则局域网中的客户端要访问 Internet，则需要通过代理服务器来访问，
>   - 这种代理服务就称为正向代理。
> - 反向代理
>   - 反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，
>   - 我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，
>   - 在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，
>   - 暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。
> - 负载均衡
>   - 客户端发送多个请求到服务器，服务器处理请求，
>   - 有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。
>   - 这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，
>   - 成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，
>   - 以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，
>   - 并发量特别大的时候，还容易造成服务器直接崩溃。
>   - 很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？
>   - 我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，
>   - 加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，
>   - 硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，
>   - 天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，
>   - 将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？
>   - 上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题
>   - 的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，
>   - 单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，
>   - 将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，
>   - 将负载分发到不同的服务器，也就是我们所说的 负载均衡
> - 动静分离
>   - 为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，
>   - 加快解析速度。降低原来单个服务器的压力。

# 反向代理实例一

> 实现效果：使用 nginx 反向代理，访问 www .123 .com 直接跳转到 127.0.0.1:8080

```nginx
server {
    listen       80;
    server_name  www.123.com;

    location / {
        proxy_pass http://localhost:15015;
        index  index.html index.htm index.jsp;
    }
}
```

> 如上配置,我们监听 80 端口,访问域名为 www.123.com,不加端口号时默认为80端口,
>
> 故访问该域名时会跳转到127.0.0.1:8080路径上

# 反向代理实例二

> 实现效果：使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中。nginx 监听端口为 9001。
> 访问 http://127.0.0.1:9001/edu/ 直接跳转到 127.0.0.1:8081
> 访问 http://127.0.0.1:9001/vod/ 直接跳转到 127.0.0.1:8082

```nginx
server {
    listen       9001;
    server_name  www.123.com;

    location ~ /edu/ {
        proxy_pass http://localhost:8001;
    }

    location ~ /vod/ {
        proxy_pass http://localhost:8002;
    }
}
```

> location  指令说明 ：该指令用于匹配 URL。
>
> 语法如下：

```nginx
location [ = | ~ | ~* | ^~] uri{
    proxy_pass http://localhost:8001;
}
```

> - =    ：用于不含正则表达式的 uri 前,要求请求字符串与 uri 严格匹配,如果匹配成功,就停止继续向下搜索并立即处理该请求。
> - ~    ：用于表示 uri 包含正则表达式，并且区分大小写。
> - ~*  ：用于表示 uri 包含正则表达式，并且不区分大小写。
> - ^~  ：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字
>   符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location
>   块中的正则 uri 和请求字符串做匹配。
> - 注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识

# Nginx配置实例- 负载均衡	

```nginx
server {
    listen       9001;
    server_name  www.123.com;
	
    location / {
      proxy_pass http://myserver;
	  proxy_connect_timeout 10;
    }

}
```
# Nginx负载均衡分配方式(策略)：

## 轮询（默认）

> 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。

## weight(权重)

> weight 代表权,重默认为 1,权重越高被分配的客户端越多
>
> 指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。

```nginx
upstream server_pool {
    server 192.168.5.21 weight = 10 ;
    server 192.168.5.22 weight = 10 ;
}
```

## ip_hash(ip的hash值)

> 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。 

```nginx
upstream server_pool {
ip_hash ;
    server 192.168.5.21:80 ;
    server 192.168.5.22:80 ;
}
```

## fair （第三方）

> 按后端服务器的响应时间来分配请求，响应时间短的优先分配。

```nginx
upstream server_pool {
    server 192.168.5.21:80 ;
    server 192.168.5.22:80 ;
    fair ;
}
```

# Nginx配置实例- 动静分离

> - 动态请求跟静态请求分开,可以理解成使用 Nginx处理静态页面,Tomcat 处理动态页面。
> - 动静分离从目前实现角度来讲大致分为两种：
>   - 一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；
>   - 另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。
>     - 通过 location 指定不同的后缀名实现不同的请求转发。
>     - 通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。
>     - 具体 Expires 定义：
>       - 是给一个资源设定一个过期时间，也就是说无需去服务端验证，
>       - 直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。
>       - 此种方法非常适合不经常变动的资源。
>       - （如果经常更新的文件，不建议使用 Expires 来缓存），
>       - 我这里设置 3d，表示在这 3 天之内访问这个 URL，
>       - 发送一个请求，比对服务器该文件最后更新时间没有变化，
>       - 则不会从服务器抓取，返回状态码304，如果有修改，
>       - 则直接从服务器重新下载，返回状态码 200。

```nginx
server {
	listen       81;
	server_name  qbsrnq.natappfree.cc;	
	location ~ /web/ {
	   root C:/zhaoyang/tool/nginx-1.17.8/html/web/web;
	   index  index.html index.htm;
	}
	
	location /www1/ {
	   root C:/zhaoyang/tool/nginx-1.17.8/html/web/www;
	   index  index.html index.htm;
	}
	
	location /www2/ {
	   root C:/zhaoyang/tool/nginx-1.17.8/html/web/www;
	   antoindex on;
	}
}
```
# Nginx原理与优化参数配置

> - worker_processes
>   - 需要设置多少个 worker_processes
>   - worker_processes数和服务器的 cpu数相等是最为适宜的。
>   - 设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗
> - 连接数 worker_connection