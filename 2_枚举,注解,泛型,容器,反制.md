# 枚举

> 当需要定义一组常量时，强烈建议使用枚举类，使用enum关键字定义枚举类

# 枚举类的定义

```java
public enum PayType {
    ALIPAY(1, "支付宝"),
    WEIXINPAY(2, "微信"),
    PAYPAL(3, "PAYPAL"),
    BANK(4,"银行卡"),
    CREDIT(5,"信用卡"),
    BALANCE(4, "余额")
    ;

    private final Integer payCode;
    private final String payName;

    private PayType(Integer payCode, String payName) {
        this.payCode = payCode;
        this.payName = payName;
    }

    public Integer getPayCode() {
        return payCode;
    }

    public String getPayName() {
        return payName;
    }
}
```

# 实现接口的枚举类

> - [ ] 和普通 Java 类一样,枚举类可以实现一个或多个接口。
> - [ ] 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只
>   要统一实现该方法即可。
> - [ ] 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式,则可以让每个枚举值分别来实现该方法。

```java
/**
 * 季节枚举类
 */
public enum SeasonType implements Info {
    SPRING(1, "春天") {
        @Override
        public String show() {
            return "季节编码:" + getSeasonCode() + "-" + "季节名称:" + getSeasonName();
        }
    },
    SUMMER(2, "夏天") {
        @Override
        public String show() {
            return "季节编码:" + getSeasonCode() + "-" + "季节名称:" + getSeasonName();
        }
    },
    AUTUMN(3, "秋天") {
        @Override
        public String show() {
            return "季节编码:" + getSeasonCode() + "-" + "季节名称:" + getSeasonName();
        }
    },
    WINTER(4, "冬天") {
        @Override
        public String show() {
            return "季节编码:" + getSeasonCode() + "-" + "季节名称:" + getSeasonName();
        }
    };
    private final Integer seasonCode;
    private final String seasonName;

    SeasonType(Integer seasonCode, String seasonName) {
        this.seasonCode = seasonCode;
        this.seasonName = seasonName;
    }

    public String getSeasonName() {
        return seasonName;
    }

    public Integer getSeasonCode() {
        return seasonCode;
    }
}

interface Info {
    String show();
}

class SeasonEnumTets1 {
    public static void main(String[] args) {
        //遍历所有枚举对象并调用show方法
        for (SeasonType value : SeasonType.values()) {
            System.out.println(value.show());
        }
    }
}
```

# 注解(Annotation)

> - [ ] **Annotation**就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。
>
> - [ ] 通过使用**Annotation**,程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。

# JDK内置的三个基本注解

> - [ ] @Override: 限定重写父类方法, 该注解只能用于方法
> - [ ] @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择
> - [ ] @SuppressWarnings: 抑制编译器警告

# Collection子接口之一:List接口

> 1.鉴于Java中数组用来存储数据的局限性,通常使用List替代数组.
> 2.List特点元素有序、且可重复,集合中的每个元素都有其对应的顺序索引.
> 3.List中的元素都对应一个整数型的序号记载其在容器中的位置,可以根据序号存取容器中的元素.
> 4.常用实现类有:ArrayList、LinkedList和Vector.

## 1.ArrayList

>  *   是大小可变数组的实现,存储在内的数据称为元素.ArrayList 中可不断添加元素，其大小也自动增长
>  *   元素增删慢,查找快.是最常用的集合。
>  *   切记不可随意地使用ArrayList完成任何需求,并不严谨,这种用法是不提倡的。
>
>  *   JDK1.7:ArrayList像饿汉式,直接创建一个初始容量为10的数组
>  *   JDK1.8:ArrayList像懒汉式,一开始创建一个长度为0的数组,当添加第一个元素时再创建一个始容量为10的数组
>  *   ArrayList不能存储基本类型,基本数据类型对应的包装类型可以

## 2.LinkedList

> *  LinkedList:双向链表,内部没有声明数组,而是定义了Node类型的first和last,用于记录首尾元素.
> *  同时,定义内部类Node,作为LinkedList中保存数据的基本结构。
> *  Node除了保存数据,还定义了两个变量：
>    *   prev变量记录前一个元素的位置
>    *   next变量记录下一个元素的位置
> *  对于频繁的插入或删除元素的操作,建议使用LinkedList类,效率较高

## 3.Vector

> *  Vector是一个古老的集合,JDK1.0就有了。
> *  大多数操作与ArrayList相同,区别之处在于Vector是线程安全的。
> *  在各种list中,最好把ArrayList作为缺省选择。
> *  当插入、删除频繁时,使用LinkedList:Vector总是比ArrayList慢,所以尽量避免使用。
> *  线程安全的

## ArrayList/LinkedList/Vector的异同?谈谈你的理解?ArrayList底层是什么?扩容机制?Vector和ArrayList的最大区别?

> ArrayList和LinkedList的异同:
>
> * 二者都线程不安全,相对线程安全的Vector,执行效率高。
> * ArrayList是实现了基于动态数组的数据结构,LinkedList基于链表的数据结构。
> * 对于随机访问get和set,ArrayList觉得优于LinkedList,因为LinkedList要移动指针。
> * 对于新增和删除操作add(特指插入)和remove,LinkedList比较占优势,因为ArrayList要移动数据。
>
> ArrayList和Vector的区别:
>
> *  Vector和ArrayList基本差不多,区别在于Vector是同步类(synchronized)属于强同步类
>
> *  因此开销就比ArrayList要大,访问要慢。
> *  正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步可以自己控制
> *  Vector每次扩容请求其大小的2倍空间,而ArrayList是1.5倍

## ArrarList和LinkedList区别

（1）ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。

（2）对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。

（3）对于插入和删除操作add和remove，LinkedList比较占优势，因为ArrayList每插入或删除一条数据，都要移动插入点或删除点及之后的所有数据。

# Collection子接口之Set接口

> 无序性:不是随机性,是你添加数据的时候不能按照数组索引的顺序添加,而是根据哈希值决定的
>
> 不可重复性:保证添加的元素按照equals判断时,不能返回true。就是相同元素只能填一次

## Set实现类HashSet

> 线程不安全，可以存储null值

## 向HashSet中添加元素的过程

> 当向HashSet中添加**元素A**时,首先调用**元素A**所在类的hashCode()方法,计算**元素A**的哈希值。
>
> 把**元素A**的哈希值按照某种算法来计算,从而算出**元素A**在HashSet底层数组中的所在位置(即为:**索引位置**)。
>
> 然后判断数组对应索引位置上是否已经存在了其他元素:{
>
> ​		如果此位置上没有其他元素,则**元素A**添加成功。  **(情况1)**
>
> ​		如果此位置上已有其他**元素B**(或者以链表形式存在的多个元素)时,则比较**元素A**与**元素B**的hash值:{
>
> ​				如果hash值不相同,则**元素A**添加成功。 (**情况2**)
>
> ​				如果hash值相同,进而需要调用元素A所在类的equlas()方法:
>
> ​					返回true**元素A**添加失败,
>
> ​					返回false,**元素A**添加成功。(**情况3**)
>
> ​		}
>
> }
>
> 对于添加元素成功的情况2和3而言:**元素A**与已经在索引位置上存在的数据以链表的方式存储。
>
> 链表存储格式在jdk7中：元素A放到数组中,指向原来的元素。
>
> 链表存储格式在jdk8中：原来的元素放在数组中,指向A。
>
> 好记忆就是**七上八下**。
>
> 扩容机制:初始容量为16,如果使用率超过0.75(16*0.75=12),就会扩大为原来的2倍(16,32,64,128)。
>
> 注意:向set中添加的数据,其所在的类一定要重写hashCode和equlas方法。
>
> ​		 重写的hashCode和equlas尽可能保持一致，相等的对象必须具有相等的散列值
>
> ​		 重写两个方法的小技巧:对象中用作equals()方法比较的Field,都应该用来计算hashCode()

## Set实现类之LinkedHashSet

> LinkedHashSet是HashSet 的子类,在添加数据的同时,每个数据还维护了两个引用,记录此数据前一个数据和后一个数据。
>
> 优点:遍历内部数据时,可以按照添加的顺序去遍历,对应比较频繁的遍历操作LinkedHashSet性能高于HashSet。

## Set实现类之TreeSet

> 可以按照添加对象的指定属性进行排序
>
> 1.像treeSet中添加的数据,要求是相同类的对象。
>
> 2.如果试图把一个对象添加到TreeSet时,则该对象的类必须实现Comparable接口,实现compareTo(Object obj) 方法
>
> 3.Comparable的典型实现:
>
> ​	  3.1.BigDecimal,BigInteger以及所有的数值型对应的包装类:按它们对应的数值大小进行比较。
>
> ​	  3.2.Character:按字符的 unicode值来进行比较。
>
> ​	  3.3.Boolean:true 对应的包装类实例大于 false 对应的包装类实例。
>
> ​	  3.4.String:按字符串中字符的 unicode 值进行比较。
>
> ​	  3.5.Date,Time:后边的时间、日期比前面的时间、日期大。
>
> 4.排序:
>
> ```java
> /**
>  * 自然排序
>  * 向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。
>  * 因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象。
>  * 对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值。
>  * 当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保
>  * 证该方法与 compareTo(Object obj) 方法有一致的结果：如果两个对象通过
>  * equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0。否则，让人难以理解。
>  *
>  * 定制排序
>  *  TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没
>  * 有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照
>  * 其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来
>  * 实现。需要重写compare(T o1,T o2)方法。
>  *  利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表
>  * 示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。
>  *  要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构
>  * 造器。
>  *  此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异
>  * 常。
>  *  使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。
>  */
> ```

## 面试题

#### 集合Collection中存储的如果是自定义类的对象，需要自定义类重写哪个方法？为什么？

1.List：equals()方法

2.HashSet、LinkedHashSet：equals()、hashCode()

3.TreeSet：Comparable:compareTo(),Comparator:compare()

### 简述常见的数据结构中元素的存取特点

```java
/**
 * 栈：stack，又称堆栈，对元素的存取特点是：先进后出。即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素。
 * 队列：queue，简称队，对元素的存取特点是：先进先出。即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素。
 * 数组:Array，是有序的元素序列，对元素的存取特点是：
 *      1、查找元素快：通过索引，可以快速访问指定位置的元素
 *      2、增删元素慢
 *          （1）指定索引位置增加元素:需要创建一个新数组,将指定新元素存储在指定索
 *               引位置,再把原数组元素根据索引,复制到新数组对应索引的位置。
 *          （2）指定索引位置删除元素:需要创建一个新数组,把原数组元素根据索引，
 *              复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。
 * 链表:linked list,对元素的存取有如下的特点：
 *      1、多个结点之间,通过地址进行连接。
 *          例如,多个人手拉手,每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。
 *      2、查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。
 *      3、增删元素快：
 *          增加元素：只需要修改连接下个元素的地址即可。
 *          删除元素：只需要修改连接下个元素的地址即可。
 */
```

### 数据结构

数据存储的常用结构有：栈、队列、数组、链表和红黑树

![image-20200606101111389](C:\Users\Administrator.DESKTOP-8F1MHB5\Desktop\2020.03.24\基础\image\image-20200606101111389.png)

![image-20200606101457954](C:\Users\Administrator.DESKTOP-8F1MHB5\Desktop\2020.03.24\基础\image\image-20200606101457954.png)

![image-20200606101835927](C:\Users\Administrator.DESKTOP-8F1MHB5\Desktop\2020.03.24\基础\image\image-20200606101835927.png)

![image-20200606102039399](C:\Users\Administrator.DESKTOP-8F1MHB5\Desktop\2020.03.24\基础\image\image-20200606102039399.png)

![image-20200606102232890](C:\Users\Administrator.DESKTOP-8F1MHB5\Desktop\2020.03.24\基础\image\image-20200606102232890.png)

# 

### 简述Comparable和Comparator两个接口的区别

> Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。
>
> 
>
> Comparator强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。

# Map

> Map存储结构的理解：
>
> > key:是无序的,不可重复的,使用Set存储所有的key,key所在的类要重写equals()和hashCode()(HashMap例)
> >
> > value:无序的,可重复的,使用Collection存储所有的value,value所在的类要重写equals()
> >
> > key和value构成了一个Entry对象。
> >
> > Entry:无序的,不可重复的,使用Set存储所有的entry

## HashMap

> 线程不安全的,效率高:key和value可以为null。

## LinkedHashMap

> 可以按照添加时的顺序实现遍历。
>
> 因为在HashMap底层结构基础上,添加了一对指针,指向前一个和后一个元素。
>
> 对于频繁的遍历操作,此类执行效率高于HashMap。

## TreeMap

> 可以按照key-value进行排序。
>
>  *              有自然排序(Comparable.compareTo())
>  *              定制排序(Comparator.compare()).
>  *              底层使用红黑树

## Hashtable

> 线程安全的,效率低;不能存储null的key和value,常用来处理配置文件key和value都是String类型

## HashMap的底层实现原理？

> HashMap在jdk7中实现原理:数组+链表
>
> - HashMap map = new HashMap():在实例化以后,底层创建了长度是16的一维数组Entry[] table。
> - map.put(key1,value1)时:
>   - 首先,调用key1所在类的hashCode()计算key1哈希值，
>   - 此哈希值经过某种算法计算以后，
>   - 得到在Entry数组中的存放位置。
>   - 如果此位置上的数据为空,此时的key1-value1添加成功。(**情况1**)
>   - 如果此位置上的数据不为空，(意味着此位置上存在一个或多个以链表形式存在数据),比较key1和已经存在的一个或多个数据的哈希值：
>     - 如果key1的哈希值与已经存在的数据的哈希值都不相同,此时key1-value1添加成功。(**情况2**)
>     - 如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：
>       - 如果equals()返回false:此时key1-value1添加成功。(**情况3**)
>       - 如果equals()返回true:使用value1替换value2。
> - 如果你多次put后key1-value1和原来的数据以链表的方式存储(情况2和情况3)
> - 在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。
> - 默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。
>
> HashMap在jdk8中相较于jdk7在底层实现方面的不同：
>
> - new HashMap():底层没创建一个长度为16的数组
> - jdk 8底层的数组是：Node[],而非Entry[]
> - 首次调用put()方法时，底层创建长度为16的数组
> - jdk7底层结构：数组+链表。jdk8中底层结构：数组+链表+红黑树。
> - 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）
> - 当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且当前数组的长度 > 64时，此时此索引位置上的所数据改为使用红黑树存储。

## Collection 和 Collections的区别？

> Collection是一个接口子类有list set
>
> Collections是一个工具类里面提供了一些静态方法