# =======数据库相关======

## 1.数据库的好处

> 实现数据的持久化,有对应的管理系统,方便查询。
>
> 常见的时间有MySQL、Oracle、SqlServer等

## 2.什么是三大范式

> - 第一范式:1NF要求数据库表的每一列都是不可分割的原子数据项。
> - 第二范式:2NF确保数据库表中的每一列都和主键相关,而不能只与主键的某一部分相关。
> - 第三范式:3NF是在满足第二范式的前提下,确保数据表中的每一列数据都和主键直接相关,而不能间接相关  	  

## 3.说说什么是索引吗

> 答:索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据,可以提高MySQL的检索速度

## 4.索引具体采用的哪种数据类型和数据结构呢？

> mysql索引类型:普通索引,唯一索引,全文搜索的索引,空间索引
>
> MySQL索引方式有两种:Hash,B+Tree(InnoDB引擎，默认的是B+树)    

## 5.B+Tree索引和Hash索引区别？

> ①.哈希索引适合等值查询，但是无法进行范围查询
> ②.哈希索引没办法利用索引完成排序
> ③.哈希索引不支持多列联合索引的最左匹配规则
> ④.如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题
> ⑤.Hash索引底层是哈希表,哈希表是一种以key-value存储数据的结构。
>   所以多个数据在存储关系上是完全没有任何顺序关系的。
>   所以对于区间查询是无法直接通过索引查询的,就需要全表扫描。
>   所以哈希索引只适用于等值查询的场景。
> ⑥.而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描

## 6.联合索引的规则

> ①.组合索引使用最左前缀匹配原则,mysql会一直从左开始向右匹配直到遇到范围查询(>、<、between、like)就停止匹配。
> ②.比如[ a=1 AND b=2 AND c>3 AND d=4 ]
>    如果建立(a,b,c,d)顺序的索引,d是用不到索引的
>    如果建立(a,b,d,c)的索引则都可以用到,a,b,d的顺序可以任意调整
> ③.在创建多列索引时,根据业务需求,where子句中使用最频繁的一列放在最左边,因为MySQL索引查询会遵循最左前缀匹配的原则,即最左优先。

## 7.查看索引是否生效

> 答:可以通过explain查看sql语句的执行计划,通过执行计划来分析索引使用情况,一般遇到慢查询的时候去排查。

## 8.什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？

> 答:①.一条SQL语句的查询,可以有不同的执行方案,至于最终选择哪种方案,需要通过优化器进行选择,选择执行成本最低的方案。
>   ②.在一条单表查询语句真正执行之前,MySQL的查询优化器会找出执行该语句所有可能使用的方案,对比之后找出成本最低的方案   

## 9.mysql变量

> 答:系统变量:全局变量,会话变量
>   自定义变量:用户变量,局部变量  

## 10.什么是存储过程？用什么来调用？

> 答:存储过程是一个预编译并存储在数据库的SQL语句，就是我只需创建一次，以后在该程序中就可以调用多次
>  CREATE PROCEDURE 存储过程名(参数列表)
>  BEGIN
> 		存储过程体（一组合法的SQL语句）;
>  END;
>  CALL 存储过程名(参数列表);

## 11.存储过程的优缺点？

> 答: 优点：存储过程是预编译过的，执行效率高。
> 		 存储过程直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
> 		 安全性高，执行存储过程需要有一定权限的用户。
> 		 存储过程可以重复使用，可减少数据库开发人员的工作量。
>    缺点：移植性差   

## 12.存储过程与函数的区别

> 答: 存储过程可以有1个返回值或多个返回值,也可以没有返回值
> 	  函数只能有1个返回。	

## 13.触发器的作用？

> 答:触发器是与表有关的数据库对象在 insert/update/delete 之前或之后,
>   触发并执行触发器中定义的SQL语句集合
>   触发器还只支持行级触发，不支持语句级触发

## 14.什么是 内连接、外连接、交叉连接、笛卡尔积等?

> 答:内连接: 匹配的就链接
>   左外连接: 包含左边表的全部行，以及右边表中全部匹配的行（不管右边的表中是否存在与它们匹配的行）
>   右外连接: 包含右边表的全部行，以及左边表中全部匹配的行（不管左边的表中是否存在与它们匹配的行）
>   全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。
>   交叉连接: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配

## 15.什么是事务

> 答:一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。
>   事务又分 隐式事务(如insert、update、delete语句),显式事务(SET autocommit=0)

## 16.事务的四个特性(ACID)

> - 原子性(atomicity)   事务中所有操作,要么全成功;要么撤回到执行事务之前的状态
> - 一致性(consistency) 一个事务中不管涉及到多少个操作,都必须保证事务执行之前和之后数据都是正确的。如果一个事务在执行的过程中，其中某一个或某几个操作失败了，则必须进行回滚。
> - 隔离性(isolation)   事务操作之间彼此独立和透明互不影响。事务独立运行。这通常使用锁来实现。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。
> - 持久性(durability)  事务一旦提交，其结果就是永久的。即便发生系统故障，也能恢复

## 17数据库的并发问题

> - 同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:
>   - **脏读**: 一个事务可以读取另一个事务未提交的数据.
>   - **不可重复读**: 一个事务可以读取另一个事务已提交的数据,单条记录前后不匹配.
>   - 虚读（幻读） 一个事务可以读取另一个事务已提交的数据,读取的数据前后多了点或者少了点.
> - 解决读问题： 设置事务隔离级别
> - **数据库事务的隔离性**: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。
> - 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, **隔离级别越高, 数据一致性就越好, 但并发性越弱。**

## 18.事务隔离级别

> - 未提交读(Read Uncommitted)：
>   - 允许脏读，其他事务只要修改了数据，即使未提交，本事务也能看到修改后的数据值。
>         也就是可能读取到其他会话中未提交事务修改的数据
> - 提交读(Read Committed)：
>   - 只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)。    
> - 可重复读(Repeated Read)：
>   - 可重复读。无论其他事务是否修改并提交了数据，在这个事务中看到的数据值始终不受其他事务影响。
> - 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，
> - 读写相互都会阻塞
> - MySQL数据库(InnoDB引擎)默认使用可重复读（ Repeatable read) 隔离级别越高，性能越低。
> - 一般情况下：脏读是不可允许的，不可重复读和幻读是可以被适当允许的。
>   - 查看隔离级别 **select @@tx_isolation**;
>   - 设置隔离级别 **set session|global transaction isolation level** {隔离级别};

# =======JDBC相关======

# Java与SQL对应数据类型转换表

| Java类型           | SQL类型                  |
| ------------------ | ------------------------ |
| boolean            | BIT                      |
| byte               | TINYINT                  |
| short              | SMALLINT                 |
| int                | INTEGER                  |
| long               | BIGINT                   |
| String             | CHAR,VARCHAR,LONGVARCHAR |
| byte   array       | BINARY  ,    VAR BINARY  |
| java.sql.Date      | DATE                     |
| java.sql.Time      | TIME                     |
| java.sql.Timestamp | TIMESTAMP                |

# 使用Statement操作数据表的弊端

> - 存在的问题
>
>   - 存在拼串操作，繁琐
>   - 存在SQL注入问题
>
>   
>
> - 问题案例
>
>   - ```java
>     //注入的sql样本【SELECT user,password FROM user_table WHERE user = '1' or ' AND password = '=1 or '1' = '1'】
>     String user = "1' or ";
>     String password = "=1 or '1' = '1";
>     String sql = "SELECT user,password FROM user_table WHERE user = '"+ user +"' AND password = '"+ password +"'";
>     ```
>
> - 解决案例
>
>   - 要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。
>   - 使用PreparedStatement替换Statement实现的查询操作，解决Statement拼串和SQL注入问题

# PreparedStatement与Statement对比

> - 代码的可读性和可维护性高。
> - **PreparedStatement 能最大可能提高性能：**
>   - DBServer会对**预编译**语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u>
>   - 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u>
>   - (语法检查，语义检查，翻译成二进制命令，缓存)
> - PreparedStatement 可以防止 SQL 注入 