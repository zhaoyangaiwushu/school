# =======数据库相关======

## 1.数据库的好处

> 实现数据的持久化,有对应的管理系统,方便查询。
>
> 常见的时间有MySQL、Oracle、SqlServer等

## 2.什么是三大范式

> - 第一范式:1NF要求数据库表的每一列都是不可分割的原子数据项。
> - 第二范式:2NF确保数据库表中的每一列都和主键相关,而不能只与主键的某一部分相关。
> - 第三范式:3NF是在满足第二范式的前提下,确保数据表中的每一列数据都和主键直接相关,而不能间接相关  	  

## 3.说说什么是索引吗

> 答:索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据,可以提高MySQL的检索速度

## 4.索引具体采用的哪种数据类型和数据结构呢？

> mysql索引类型:普通索引,唯一索引,全文搜索的索引,空间索引
>
> MySQL索引方式有两种:Hash,B+Tree(InnoDB引擎，默认的是B+树)    

## 5.B+Tree索引和Hash索引区别？

> ①.哈希索引适合等值查询，但是无法进行范围查询
> ②.哈希索引没办法利用索引完成排序
> ③.哈希索引不支持多列联合索引的最左匹配规则
> ④.如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题
> ⑤.Hash索引底层是哈希表,哈希表是一种以key-value存储数据的结构。
>   所以多个数据在存储关系上是完全没有任何顺序关系的。
>   所以对于区间查询是无法直接通过索引查询的,就需要全表扫描。
>   所以哈希索引只适用于等值查询的场景。
> ⑥.而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描

## 6.联合索引的规则

> ①.组合索引使用最左前缀匹配原则,mysql会一直从左开始向右匹配直到遇到范围查询(>、<、between、like)就停止匹配。
> ②.比如[ a=1 AND b=2 AND c>3 AND d=4 ]
>    如果建立(a,b,c,d)顺序的索引,d是用不到索引的
>    如果建立(a,b,d,c)的索引则都可以用到,a,b,d的顺序可以任意调整
> ③.在创建多列索引时,根据业务需求,where子句中使用最频繁的一列放在最左边,因为MySQL索引查询会遵循最左前缀匹配的原则,即最左优先。

## 7.查看索引是否生效

> 答:可以通过explain查看sql语句的执行计划,通过执行计划来分析索引使用情况,一般遇到慢查询的时候去排查。

## 8.什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？

> 答:①.一条SQL语句的查询,可以有不同的执行方案,至于最终选择哪种方案,需要通过优化器进行选择,选择执行成本最低的方案。
>   ②.在一条单表查询语句真正执行之前,MySQL的查询优化器会找出执行该语句所有可能使用的方案,对比之后找出成本最低的方案   

## 9.mysql变量

> 答:系统变量:全局变量,会话变量
>   自定义变量:用户变量,局部变量  

## 10.什么是存储过程？用什么来调用？

> 答:存储过程是一个预编译并存储在数据库的SQL语句，就是我只需创建一次，以后在该程序中就可以调用多次
>  CREATE PROCEDURE 存储过程名(参数列表)
>  BEGIN
> 		存储过程体（一组合法的SQL语句）;
>  END;
>  CALL 存储过程名(参数列表);

## 11.存储过程的优缺点？

> 答: 优点：存储过程是预编译过的，执行效率高。
> 		 存储过程直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
> 		 安全性高，执行存储过程需要有一定权限的用户。
> 		 存储过程可以重复使用，可减少数据库开发人员的工作量。
>    缺点：移植性差   

## 12.存储过程与函数的区别

> 答: 存储过程可以有1个返回值或多个返回值,也可以没有返回值
> 	  函数只能有1个返回。	
> 	
> 	

## 13.触发器的作用？

> 答:触发器是与表有关的数据库对象在 insert/update/delete 之前或之后,
>   触发并执行触发器中定义的SQL语句集合
>   触发器还只支持行级触发，不支持语句级触发

## 14.什么是 内连接、外连接、交叉连接、笛卡尔积等?

> 答:内连接: 匹配的就链接
>   左外连接: 包含左边表的全部行，以及右边表中全部匹配的行（不管右边的表中是否存在与它们匹配的行）
>   右外连接: 包含右边表的全部行，以及左边表中全部匹配的行（不管左边的表中是否存在与它们匹配的行）
>   全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。
>   交叉连接: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配

## 15.什么是事务

> 答:一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。
>   事务又分 隐式事务(如insert、update、delete语句),显式事务(SET autocommit=0)

## 16.事务的四个特性(ACID)

> - 原子性(atomicity)   事务中所有操作,要么全成功;要么撤回到执行事务之前的状态
> - 一致性(consistency) 一个事务中不管涉及到多少个操作,都必须保证事务执行之前和之后数据都是正确的。如果一个事务在执行的过程中，其中某一个或某几个操作失败了，则必须进行回滚。
> - 隔离性(isolation)   事务操作之间彼此独立和透明互不影响。事务独立运行。这通常使用锁来实现。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。
> - 持久性(durability)  事务一旦提交，其结果就是永久的。即便发生系统故障，也能恢复

## 16.事务隔离级别

> - 未提交读(Read Uncommitted)：
>   - 允许脏读，其他事务只要修改了数据，即使未提交，本事务也能看到修改后的数据值。
>         也就是可能读取到其他会话中未提交事务修改的数据
> - 提交读(Read Committed)：
>   - 只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)。    
> - 可重复读(Repeated Read)：
>   - 可重复读。无论其他事务是否修改并提交了数据，在这个事务中看到的数据值始终不受其他事务影响。
> - 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，
> - 读写相互都会阻塞
> - MySQL数据库(InnoDB引擎)默认使用可重复读（ Repeatable read) 隔离级别越高，性能越低。
> - 一般情况下：脏读是不可允许的，不可重复读和幻读是可以被适当允许的。
>   - 查看隔离级别select @@tx_isolation;
>   - 设置隔离级别set session|global transaction isolation level {隔离级别};

## 17.脏读、幻读、不可重复读

> - 事务并发引起一些读的问题:
>   - 脏读         一个事务可以读取另一个事务未提交的数据.
>   - 不可重复读   一个事务可以读取另一个事务已提交的数据,单条记录前后不匹配.
>   - 虚读（幻读） 一个事务可以读取另一个事务已提交的数据,读取的数据前后多了点或者少了点.
>   - 解决读问题： 设置事务隔离级别